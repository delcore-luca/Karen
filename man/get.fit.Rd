% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{get.fit}
\alias{get.fit}
\title{Fit the state-space model to a clonal tracking dataset}
\usage{
get.fit(
  rct.lst,
  constr.lst,
  latSts.lst,
  ct.lst,
  Y,
  m0,
  P0,
  cl = getDefaultCluster(),
  control = list(nLQR = 3, lmm = 25, pgtol = 0, relErrfct = 1e-05, tol = 1e-09, maxit =
    1000, maxitEM = 10, trace = 1, FORCEP = TRUE)
)
}
\arguments{
\item{rct.lst}{A list of biochemical reactions defining the cell differentiation network.
A differentiation move from cell type "A" to cell type "B" must be coded as "A->B"
Duplication of cell "A" must be coded as "A->1"
Death of cell "A" must be coded as "A->0".}

\item{constr.lst}{List of linear constraints that must be applied to the biochemical reactions.
For example, if we need the constraint "A->B = B->C + B->D", this must be coded using the following syntax
c("theta\[\\'A->B\\'\]=(theta\[\\'B->C\\'\] + theta\[\\'B->D\\'\])").}

\item{latSts.lst}{List of the latent cell types. If for example counts are not available for cell types "A" and "B", then latSts.lst = c("A", "B").}

\item{ct.lst}{List of all the cell types involved in the network formulation.
For example, if the network is defined by the biochemical reactions are A->B" and "A->C", then ct.lst = c("A", "B", "C").}

\item{Y}{A 3-dimensional array whose dimensions are the time, the cell type and the clone respectively.}

\item{m0}{mean vector of the initial condition \eqn{x_0}{x0}}

\item{P0}{covariance matrix of the initial condition \eqn{x_0}{x0}}

\item{cl}{An object of class "cluster" specifying the cluster to be used for parallel execution. See makeCluster for more information.
If the argument is not specified, the default cluster is used. See setDefaultCluster for information on how to set up a default cluster.}

\item{control}{A a list of control parameters for the optimization routine:
\itemize{
\item{"nLQR"}{(defaults to 3) is an integer giving the order of the Gauss-Legendre approximation for integrals.}
\item{"lmm"}{(defaults to 25) is an integer giving the number of BFGS updates retained in the "L-BFGS-B" method.}
\item{"pgtol"}{(defaults to 0 when check is suppressed) is a tolerance on the projected gradient
in the current search direction of the "L-BFGS-B" method.}
\item{"relErrfct"}{(defaults to 1e-5) is the relative error on the function value for the "L-BFGS-B" optimization.
That is, the parameter "factr" of the optim() function is set to relErrfct/.Machine$double.eps.}
\item{"tol"}{(defaults to 1e-9) is the relative error tolerance for the expectation-maximization algorithm
of the extended Kalman filter optimization. That is, the optimization is run until the relative error of the function
and of the parameter vector are lower than tol.}
\item{"maxit"}{(defaults to 1000) The maximum number of iterations for the "L-BFGS-B" optimization.}
\item{"maxitEM"}{(defaults to 10) The maximum number of iterations for the expectation-maximization algorithm.}
\item{"trace"}{(defaults to 1) Non-negative integer. If positive, tracing information on the progress of the optimization is produced.
This parameter is also passed to the optim() function.
Higher values may produce more tracing information: for method "L-BFGS-B" there are six levels of tracing.
(To understand exactly what these do see the source code: higher levels give more detail.)}
\item{"FORCEP"}{(defaults to TRUE) Logical value. If TRUE, then all the covariance matrices involved in the algorithm
are forced to be positive-definite and it helps the convergence of the optimization.}
}}
}
\value{
A list containing the following:
\itemize{
\item{"fit"}{The output list returned by the optim() function (See documenttion of optim() for more details).}
\item{"bwd.res"}{First two-order moments of the estimated smoothing distribution.}
\item{"m0.res"}{Mean vector of the smoothing distribution at time t = 0.}
\item{"P0.res"}{Covariance matrix of the smoothing distribution at time t = 0.}
\item{"AIC"}{Akaike Information Criterion (AIC) of the fitted model.}
\item{"cloneChunks"}{List containing the chunks of clones that have been defined for parallel-computing.}
\item{"V"}{The net-effect matrix associated to the differentiation network.}
\item{"Y"}{The complete clonal tracking dataset that includes also the missing cell types.}
\item{"rct.lst"}{The list of biochemical reactions.}
\item{"constr.lst"}{The linear constraints applied on the reactions.}
\item{"latSts.lst"}{The missing/latent cell types.}
}
}
\description{
This function fits a state-space model to a clonal tracking dataset using an extended Kalman filter approach.
}
\examples{
\donttest{
cat("\nInstall/load packages")
inst.pkgs <- installed.packages() ## installed packages

l.pkgs <- c("expm",
            "Matrix",
            "parallel",
            "gaussquad",
            "splines",
            "scales",
            "mvtnorm",
            "tmvtnorm",
            "MASS",
            "igraph",
            "stringr",
            "Karen")
lapply(l.pkgs, function(pkg){
  if(!(pkg \%in\% rownames(inst.pkgs))){
    install.packages(pkg)
  }
})
## load packages
lapply(l.pkgs, function(pkg){library(pkg,character.only=TRUE)})

rm(list = ls())

rcts <- c("HSC->P1", ## reactions
          "HSC->P2",
          "P1->T",
          "P1->B",
          "P1->NK",
          "P2->G",
          "P2->M",
          "T->0",
          "B->0",
          "NK->0",
          "G->0",
          "M->0"
          ,"HSC->1"
          ,"P1->1"
          ,"P2->1"
)

cnstr <- c("theta\\\\[\\\\'HSC->P1\\\\'\\\\]=(theta\\\\[\\\\'P1->T\\\\'\\\\] + theta\\\\[\\\\'P1->B\\\\'\\\\] + theta\\\\[\\\\'P1->NK\\\\'\\\\])",
           "theta\\\\[\\\\'HSC->P2\\\\'\\\\]=(theta\\\\[\\\\'P2->G\\\\'\\\\] + theta\\\\[\\\\'P2->M\\\\'\\\\])") ## reaction constraints
latsts <- c("HSC", "P1", "P2") ## latent cell types

ctps <- unique(setdiff(c(sapply(rcts, function(r){ ## all cell types
  as.vector(unlist(strsplit(r, split = "->", fixed = T)))
}, simplify = "array")), c("0", "1")))

########## TRUE PARAMETERS ##########
th.true <- c(0.65, 0.9, 0.925, 0.975, 0.55, 3.5, 3.1, 4, 3.7, 4.1, 0.25, 0.225, 0.275) ## dynamic parameters
names(th.true) <- tail(rcts, -length(cnstr))
s2.true <- 1e-8 ## additonal noise
r0.true <- .1 ## intercept noise parameter
r1.true <- .5 ## slope noise parameter
phi.true <- c(th.true, r0.true, r1.true) ## whole vector parameter
names(phi.true) <- c(names(th.true), "r0", "r1")

########## SIMULATION PARAMETERS ##########
S <- 1000 ## trajectories length
nCL <- 3 ## number of clones
X0 <- rep(0, length(ctps)) ## initial condition
names(X0) <- ctps
X0["HSC"] <- 100
ntps <- 30 ## number of time-points
f_NA <- .75 ## fraction of observed data

###########################
## SIMULATE TRAJECTORIES ##
###########################

XY <- get.sim.trajectories(rct.lst = rcts,
                           constr.lst = cnstr,
                           latSts.lst = latsts,
                           ct.lst = ctps,
                           th = th.true,
                           S = S,
                           nCL = nCL,
                           X0 = X0,
                           s2 = s2.true,
                           r0 = r0.true,
                           r1 = r1.true,
                           f = f_NA,
                           ntps = ntps,
                           trunc = FALSE)

#####################################
## Fitting Karen on simulated data ##
#####################################

nProc <- 1 # number of cores
cat(paste("\tLoading CPU cluster...\n", sep = ""))
cat(paste("Cluster type: ", "PSOCK\n", sep = ""))
cpu <- Sys.getenv("SLURM_CPUS_ON_NODE", nProc) ## define cluster CPUs
hosts <- rep("localhost",cpu)
cl <- makeCluster(hosts, type = "PSOCK") ## make the cluster
rm(nProc)

## mean vector of the initial condition:
m_0 <- replicate(nCL, X0, simplify = "array")
colnames(m_0) <- 1:nCL
## covariance matrix of the initial condition:
P_0 <- Diagonal(length(ctps) * nCL, 1e-5)
rownames(P_0) <- colnames(P_0) <- rep(1:nCL, each = length(ctps))
## Fit Karen on the simulated data:
res.fit <- get.fit(rct.lst = rcts,
                   constr.lst = cnstr,
                   latSts.lst = latsts,
                   ct.lst = ctps,
                   Y = XY$Y[,setdiff(ctps, latsts),],
                   m0 = m_0,
                   P0 = P_0,
                   cl = cl,
                   list(nLQR = 3,
                        lmm = 25,
                        pgtol = 0,
                        relErrfct = 1e-9,
                        tol = 1e-9,
                        maxit = 1000,
                        maxitEM = 10,
                        trace = 1,
                        FORCEP = FALSE))

stopCluster(cl) ## stop the cluster
}
}
